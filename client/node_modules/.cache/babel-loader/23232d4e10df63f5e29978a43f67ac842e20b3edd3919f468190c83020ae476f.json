{"ast":null,"code":"import { isPlainObject } from 'is-plain-object';\nimport { Operation, Editor, Transforms, Path } from 'slate';\n\n// eslint-disable-next-line no-redeclare\nvar History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n  isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0].operations));\n  }\n};\n\n/**\n * Weakmaps for attaching state to the editor.\n */\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar SPLITTING_ONCE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n  isHistoryEditor(value) {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n  /**\n   * Get the merge flag's current value.\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n  /**\n   * Get the splitting once flag's current value.\n   */\n  isSplittingOnce(editor) {\n    return SPLITTING_ONCE.get(editor);\n  },\n  setSplittingOnce(editor, value) {\n    SPLITTING_ONCE.set(editor, value);\n  },\n  /**\n   * Get the saving flag's current value.\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n  /**\n   * Redo to the previous saved state.\n   */\n  redo(editor) {\n    editor.redo();\n  },\n  /**\n   * Undo to the previous saved state.\n   */\n  undo(editor) {\n    editor.undo();\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the first\n   * operation starts a new batch in the history. Subsequent operations will be\n   * merged as usual.\n   */\n  withNewBatch(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    SPLITTING_ONCE.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n    SPLITTING_ONCE.delete(editor);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n  withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n  withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n};\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withHistory = editor => {\n  var e = editor;\n  var {\n    apply\n  } = e;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n  e.redo = () => {\n    var {\n      history\n    } = e;\n    var {\n      redos\n    } = history;\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore);\n      }\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (var op of batch.operations) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.pop();\n      e.writeHistory('undos', batch);\n    }\n  };\n  e.undo = () => {\n    var {\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          var inverseOps = batch.operations.map(Operation.inverse).reverse();\n          for (var op of inverseOps) {\n            e.apply(op);\n          }\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n      e.writeHistory('redos', batch);\n      history.undos.pop();\n    }\n  };\n  e.apply = op => {\n    var {\n      operations,\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n    if (save == null) {\n      save = shouldSave(op);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (HistoryEditor.isSplittingOnce(e)) {\n        merge = false;\n        HistoryEditor.setSplittingOnce(e, undefined);\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        var batch = {\n          operations: [op],\n          selectionBefore: e.selection\n        };\n        e.writeHistory('undos', batch);\n      }\n      while (undos.length > 100) {\n        undos.shift();\n      }\n      history.redos = [];\n    }\n    apply(op);\n  };\n  e.writeHistory = (stack, batch) => {\n    e.history[stack].push(batch);\n  };\n  return e;\n};\n/**\n * Check whether to merge an operation into the previous operation.\n */\nvar shouldMerge = (op, prev) => {\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  return false;\n};\n/**\n * Check whether an operation needs to be saved to the history.\n */\nvar shouldSave = (op, prev) => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n  return true;\n};\nexport { HISTORY, History, HistoryEditor, MERGING, SAVING, SPLITTING_ONCE, withHistory };","map":{"version":3,"names":["History","isHistory","value","isPlainObject","Array","isArray","redos","undos","length","Operation","isOperationList","operations","HISTORY","WeakMap","SAVING","MERGING","SPLITTING_ONCE","HistoryEditor","isHistoryEditor","history","Editor","isEditor","isMerging","editor","get","isSplittingOnce","setSplittingOnce","set","isSaving","redo","undo","withMerging","fn","prev","withNewBatch","delete","withoutMerging","withoutSaving","withHistory","e","apply","batch","selectionBefore","Transforms","setSelection","withoutNormalizing","op","pop","writeHistory","inverseOps","map","inverse","reverse","lastBatch","lastOp","save","merge","shouldSave","shouldMerge","undefined","push","selection","shift","stack","type","offset","text","Path","equals","path"],"sources":["C:\\Users\\FanYukin\\codes\\f\\noints\\client\\node_modules\\slate-history\\src\\history.ts","C:\\Users\\FanYukin\\codes\\f\\noints\\client\\node_modules\\slate-history\\src\\history-editor.ts","C:\\Users\\FanYukin\\codes\\f\\noints\\client\\node_modules\\slate-history\\src\\with-history.ts"],"sourcesContent":["import { isPlainObject } from 'is-plain-object'\nimport { Operation, Range } from 'slate'\n\ninterface Batch {\n  operations: Operation[]\n  selectionBefore: Range | null\n}\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Batch[]\n  undos: Batch[]\n}\n\n// eslint-disable-next-line no-redeclare\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 ||\n        Operation.isOperationList(value.redos[0].operations)) &&\n      (value.undos.length === 0 ||\n        Operation.isOperationList(value.undos[0].operations))\n    )\n  },\n}\n","import { BaseEditor, Editor } from 'slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\nexport const SPLITTING_ONCE = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends BaseEditor {\n  history: History\n  undo: () => void\n  redo: () => void\n  writeHistory: (stack: 'undos' | 'redos', batch: any) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return History.isHistory(value.history) && Editor.isEditor(value)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the splitting once flag's current value.\n   */\n\n  isSplittingOnce(editor: HistoryEditor): boolean | undefined {\n    return SPLITTING_ONCE.get(editor)\n  },\n\n  setSplittingOnce(editor: HistoryEditor, value: boolean | undefined): void {\n    SPLITTING_ONCE.set(editor, value)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Redo to the previous saved state.\n   */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo()\n  },\n\n  /**\n   * Undo to the previous saved state.\n   */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo()\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, true)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the first\n   * operation starts a new batch in the history. Subsequent operations will be\n   * merged as usual.\n   */\n  withNewBatch(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, true)\n    SPLITTING_ONCE.set(editor, true)\n    fn()\n    MERGING.set(editor, prev)\n    SPLITTING_ONCE.delete(editor)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    fn()\n    SAVING.set(editor, prev)\n  },\n}\n","import { Editor, Operation, Path, Transforms } from 'slate'\n\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor\n  const { apply } = e\n  e.history = { undos: [], redos: [] }\n\n  e.redo = () => {\n    const { history } = e\n    const { redos } = history\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1]\n\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore)\n      }\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch.operations) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.pop()\n      e.writeHistory('undos', batch)\n    }\n  }\n\n  e.undo = () => {\n    const { history } = e\n    const { undos } = history\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.operations.map(Operation.inverse).reverse()\n\n          for (const op of inverseOps) {\n            e.apply(op)\n          }\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore)\n          }\n        })\n      })\n\n      e.writeHistory('redos', batch)\n      history.undos.pop()\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e\n    const { undos } = history\n    const lastBatch = undos[undos.length - 1]\n    const lastOp =\n      lastBatch && lastBatch.operations[lastBatch.operations.length - 1]\n    let save = HistoryEditor.isSaving(e)\n    let merge = HistoryEditor.isMerging(e)\n\n    if (save == null) {\n      save = shouldSave(op, lastOp)\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false\n        } else if (operations.length !== 0) {\n          merge = true\n        } else {\n          merge = shouldMerge(op, lastOp)\n        }\n      }\n\n      if (HistoryEditor.isSplittingOnce(e)) {\n        merge = false\n        HistoryEditor.setSplittingOnce(e, undefined)\n      }\n\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op)\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        }\n        e.writeHistory('undos', batch)\n      }\n\n      while (undos.length > 100) {\n        undos.shift()\n      }\n\n      history.redos = []\n    }\n\n    apply(op)\n  }\n\n  e.writeHistory = (stack: 'undos' | 'redos', batch: any) => {\n    e.history[stack].push(batch)\n  }\n\n  return e\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}